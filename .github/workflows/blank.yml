name: Ideas Pusher (MEXC Ultimate 7.2 - Final Fixes)

on:
  schedule:
    - cron: "0 */3 * * *"
  repository_dispatch:
    types: [run_B]
  workflow_dispatch: {}
 

permissions:
  contents: read

concurrency:
  group: ideas-mexc-ultimate
  cancel-in-progress: true

jobs:
  push:
    runs-on: ubuntu-latest
    timeout-minutes: 12

    env:
      # Required secrets
      WORKER_PUSH_URL: ${{ secrets.WORKER_PUSH_URL }}
      PUSH_TOKEN: ${{ secrets.PUSH_TOKEN }}
      WORKER_PUSH_URL_V2: ${{ secrets.WORKER_PUSH_URL_V2 }}

      # Required for trade reconciliation
      MEXC_API_KEY: ${{ secrets.MEXC_API_KEY }}
      MEXC_SECRET_KEY: ${{ secrets.MEXC_SECRET_KEY }}

      # Optional (safe defaults inside the script)
      GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
      GIST_ID: ${{ secrets.GIST_ID }}

      # Exchange + tuning knobs (via Repo/Org Variables)
      EXCHANGE: mexc
      MIN_QV_USD: ${{ vars.MIN_QV_USD }}
      TOP_N: ${{ vars.TOP_N }}
      MAX_SPREAD_BPS: ${{ vars.MAX_SPREAD_BPS }}
      EXP_LCB_MIN_BPS: ${{ vars.EXP_LCB_MIN_BPS }}
      FEES_BPS: ${{ vars.FEES_BPS }}
      NOTIONAL_USD: ${{ vars.NOTIONAL_USD }}
      MEXC_DEPTH_LIMIT: ${{ vars.MEXC_DEPTH_LIMIT }}
      OBI_TOPN: ${{ vars.OBI_TOPN }}
      ACTIVE_UTC_START: ${{ vars.ACTIVE_UTC_START }}
      ACTIVE_UTC_END: ${{ vars.ACTIVE_UTC_END }}
      MEXC_BASE: ${{ vars.MEXC_BASE }}
      FORCE_SIZE_BPS: ${{ vars.FORCE_SIZE_BPS }}
      CAPITAL_PCT_PER_TRADE: ${{ vars.CAPITAL_PCT_PER_TRADE }}

      # New Confidence Model Knobs
      DIRECTION: ${{ vars.DIRECTION }}
      MR_SLOPE_MAX_ATR50: ${{ vars.MR_SLOPE_MAX_ATR50 }}
      MR_BREAKOUT_DC_N: ${{ vars.MR_BREAKOUT_DC_N }}
      MR_BREAKOUT_RET15_ATR: ${{ vars.MR_BREAKOUT_RET15_ATR }}
      MR_LOCKOUT_SEC: ${{ vars.MR_LOCKOUT_SEC }}
      MAX_COST_BPS_HARD: ${{ vars.MAX_COST_BPS_HARD }}
      MIN_VOL_1H_USD: ${{ vars.MIN_VOL_1H_USD }}
      DEPTH_1P_MIN_USD: ${{ vars.DEPTH_1P_MIN_USD }}
      NO_LONG_DOWN_ENABLE: ${{ vars.NO_LONG_DOWN_ENABLE }}
      LONG_DOWN_RSI_CUTOFF: ${{ vars.LONG_DOWN_RSI_CUTOFF }}
      LONG_MR_DIVERGENCE_REQ: ${{ vars.LONG_MR_DIVERGENCE_REQ }}
      LONG_EDGE_MULT_MIN: ${{ vars.LONG_EDGE_MULT_MIN }}
      LONG_BOUNCE_SL_ATR: ${{ vars.LONG_BOUNCE_SL_ATR }}
      LONG_BOUNCE_TP_ATR: ${{ vars.LONG_BOUNCE_TP_ATR }}
      LONG_SIMILARITY_RHO: ${{ vars.LONG_SIMILARITY_RHO }}

      # New (MTF + Provenance + Align)
      MIN_TF_ALIGN: ${{ vars.MIN_TF_ALIGN }}
      TF_WEIGHTS: ${{ vars.TF_WEIGHTS }}
      STRATEGY_NAME: ${{ vars.STRATEGY_NAME }}
      MODEL_VERSION: ${{ vars.MODEL_VERSION }}
      SCHEMA_VERSION: ${{ vars.SCHEMA_VERSION }}
      GIT_SHA: ${{ github.sha }}

    steps:
      - name: Setup Node 20
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Run pusher (always-push + clear logs)
        shell: bash
        run: |
          set -euo pipefail

          if [[ -z "${WORKER_PUSH_URL:-}" || -z "${PUSH_TOKEN:-}" ]]; then
            echo "[gha] Missing WORKER_PUSH_URL or PUSH_TOKEN"
            exit 1
          fi

          set +e
          node - <<'NODE'
          (async ()=>{
          'use strict';
          const crypto = require('crypto');
          const MODEL_VERSION=(process.env.MODEL_VERSION||"7.2-final-fixes");
          const UA = `gh-actions-ideas-mexc-ultimate/${MODEL_VERSION} (+https://github.com/)`;

          // ---------------- Utils ----------------
          const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
          const tanh=(x)=>Math.tanh(x);
          const sum=(a)=>a.reduce((x,y)=>x+y,0);
          const mean=(a)=>a.length?sum(a)/a.length:0;
          const std=(a)=>{ const m=mean(a); let v=0; for(const x of a) v+=(x-m)*(x-m); return a.length>1?Math.sqrt(v/(a.length-1)):0; };
          const ema=(arr,p)=>{ if(!arr||arr.length<p) return null; const k=2/(p+1); let e=arr.slice(0,p).reduce((a,b)=>a+b,0)/p; for(let i=p;i<arr.length;i++) e=arr[i]*k+e*(1-k); return e; };
          const rsi=(cl,p=14)=>{ if(!cl||cl.length<=p) return null; let g=0,l=0; for(let i=1;i<=p;i++){ const d=cl[i]-cl[i-1]; g+=Math.max(0,d); l+=Math.max(0,-d); } let ag=g/p, al=l/p; for(let i=p+1;i<cl.length;i++){ const d=cl[i]-cl[i-1]; ag=(ag*(p-1)+Math.max(0,d))/p; al=(al*(p-1)+Math.max(0,-d))/p; } const rs=al===0?100:ag/al; return 100-100/(1+rs); };
          const computeADX_ATR=(h,l,c,p=14)=>{ const n=c.length; if(n<p+2) return null; const TR=[],plusDM=[],minusDM=[]; for(let i=1;i<n;i++){ const up=h[i]-h[i-1], down=l[i-1]-l[i]; plusDM.push((up>down&&up>0)?up:0); minusDM.push((down>up&&down>0)?down:0); TR.push(Math.max(h[i]-l[i], Math.abs(h[i]-c[i-1]), Math.abs(l[i]-c[i-1]))); } let trN=0,pdmN=0,ndmN=0; for(let i=0;i<p;i++){ trN+=TR[i]; pdmN+=plusDM[i]; ndmN+=minusDM[i]; } let pDI=100*(pdmN/(trN||1)), nDI=100*(ndmN/(trN||1)); let dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1), adx=dx; for(let i=p;i<TR.length;i++){ trN=trN-(trN/p)+TR[i]; pdmN=pdmN-(pdmN/p)+plusDM[i]; ndmN=ndmN-(ndmN/p)+minusDM[i]; pDI=100*(pdmN/(trN||1)); nDI=100*(ndmN/(trN||1)); dx=100*Math.abs(pDI-nDI)/((pDI+nDI)||1); adx=((adx*(p-1))+dx)/p; } const atr=trN/p; return { adx, atr, trLast: TR.at(-1) }; };
          const vwapAnchored=(h,l,c,v,win)=>{ if(!c?.length) return null; const n=c.length,s=Math.max(0,n-win); let pv=0,vv=0; for(let i=s;i<n;i++){ const tp=(h[i]+l[i]+c[i])/3; const vol=+v[i]||0; pv+=tp*vol; vv+=vol; } return vv>0?pv/vv:c.at(-1); };
          const corr=(a,b)=>{ const n=Math.min(a?.length||0,b?.length||0); if(n<5) return 0; const as=a.slice(-n), bs=b.slice(-n); const ma=mean(as), mb=mean(bs); let num=0,da=0,db=0; for(let i=0;i<n;i++){ const xa=as[i]-ma, xb=bs[i]-mb; num+=xa*xb; da+=xa*xa; db+=xb*xb; } const den=Math.sqrt(da*db)||1; return num/den; };
          const wilsonLCB=(p,n,z=1.34)=>{ if(n<=0) return p; const z2=z*z; const a=p + z2/(2*n); const b=z*Math.sqrt((p*(1-p)+z2/(4*n))/n); const c=1+z2/n; return clamp((a-b)/c, 0, 1); };
          const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));
          const jitter=(ms)=>ms + Math.floor(Math.random()*ms*0.25);
          const log=(...a)=>console.log("[gha]",...a);
          const softmax=(arr,t=20)=>{ const m=Math.max(...arr,0); const ex=arr.map(x=>Math.exp((x-m)/t)); const s=ex.reduce((a,b)=>a+b,0)||1; return ex.map(x=>x/s); };
          const sigmoid=(z)=>1/(1+Math.exp(-z));
          const logit=(p)=>{ const eps=1e-6; const pp=Math.min(1-eps,Math.max(eps,p)); return Math.log(pp/(1-pp)); };
          
          const uuidv4=()=>{ try{ return crypto.randomUUID(); }catch{ const b=crypto.randomBytes(16); b[6]=(b[6]&0x0f)|0x40; b[8]=(b[8]&0x3f)|0x80; const h=b.toString("hex"); return [h.slice(0,8),h.slice(8,12),h.slice(12,16),h.slice(16,20),h.slice(20)].join("-"); } };
          const mkClientOrderId = (prefix="mxu") => {
            const raw = (crypto.randomUUID ? crypto.randomUUID() : uuidv4()).replace(/-/g, "");
            const base = (prefix + "_" + raw).replace(/[^A-Za-z0-9_-]/g, "").slice(0, 30);
            return base.padEnd(Math.max(24, base.length), "0");
          };
          const hashObj=(o)=>{ const norm=(x)=>{ if(x&&typeof x==="object"&&!Array.isArray(x)){ const ks=Object.keys(x).sort(); const y={}; for(const k of ks) y[k]=norm(x[k]); return y; } if(Array.isArray(x)) return x.map(norm); return x; }; const s=JSON.stringify(norm(o)); return crypto.createHash("sha256").update(s).digest("hex"); };
          const toCSVLine=(row,keys)=> keys.map(k=>{ let v=row?.[k]; if(v==null) return ""; if(typeof v==="object") v=JSON.stringify(v); const s=String(v); return s.includes(",")||s.includes("\n")||s.includes('"')? `"${s.replace(/"/g,'""')}"`: s; }).join(",");

          const computeMTFIndicators=(km,weights)=>{ const TFs=["1m","3m","5m","15m","30m","1h","2h","4h","12h","1d"]; const wNorm=(()=>{ let out={}; let sw=0; for(const tf of TFs){ const w=+((weights&&weights[tf])||0); if(w>0){ out[tf]=w; sw+=w; } } if(sw<=0){ out={"1m":0.08,"3m":0.08,"5m":0.12,"15m":0.15,"30m":0.12,"1h":0.12,"2h":0.10,"4h":0.08,"12h":0.07,"1d":0.08}; sw=1; } for(const k of Object.keys(out)) out[k]=out[k]/sw; return out; })();
            const perTF={}; const agg={ rsi:0, adx:0, atr_bps:0, roc1:0, roc3:0 }; let ww=0;
            for(const tf of Object.keys(wNorm)){
              const k=km?.[tf]; if(!k?.length) continue;
              const c=k.map(x=>+x[4]), h=k.map(x=>+x[2]), l=k.map(x=>+x[3]);
              perTF[tf]={ rsi:rsi(c,14)||50, adx:(computeADX_ATR(h,l,c,14)?.adx)||0 };
              const w=wNorm[tf]; agg.rsi+=w*perTF[tf].rsi; agg.adx+=w*perTF[tf].adx; ww+=w;
            }
            if(ww<=0) return { agg:{ rsi:50, adx:0 }, tfAlign:0 };
            return { agg, weights:wNorm };
          };
          
          // ---------- HTTP + Concurrency ----------
          async function fetchWithTimeout(url,opts={},ms=12000){ const ac=new AbortController(); const t=setTimeout(()=>ac.abort(),ms); try{ return await fetch(url,{...opts,signal:ac.signal,headers:{"User-Agent":UA,...(opts?.headers||{})}});} finally{ clearTimeout(t);} }
          async function getJSON(url,ms=12000,tries=2){ for(let a=0;a<tries;a++){ try{ const r=await fetchWithTimeout(url,{},ms); if(r?.ok){ return await r.json(); } }catch{} await sleep(jitter(220)); } return null; }
          const cache={ k:new Map(), depth:new Map(), bt:new Map(), conv:new Map() };
          const TTL={ k: 60_000, depth: 8_000, bt: 5_000, conv: 60_000 };
          const getCached=(map,key,ttl)=>{ const e=map.get(key); return e && (Date.now()-e.ts<ttl)? e.v : null; };
          const setCached=(map,key,v)=>map.set(key,{ v, ts: Date.now() });

          // ---------- Config / ENV ----------
          const EXCHANGE=(process.env.EXCHANGE||"mexc").toLowerCase().replace("mexci","mexc");
          if(EXCHANGE!=="mexc"){ log("This build targets MEXC. Set EXCHANGE=mexc"); process.exit(1); }
          const MEXC_API_KEY = process.env.MEXC_API_KEY || "";
          const MEXC_SECRET_KEY = process.env.MEXC_SECRET_KEY || "";
          const MEXC_BASES=[process.env.MEXC_BASE,"https://api.mexc.com","https://www.mexc.com"].filter(Boolean);
          const MIN_TF_ALIGN=(Number(process.env.MIN_TF_ALIGN||"0.60"));
          let TF_WEIGHTS={}; try{ TF_WEIGHTS=JSON.parse(process.env.TF_WEIGHTS||"{}"); }catch{ TF_WEIGHTS={}; }
          const STRATEGY_NAME=(process.env.STRATEGY_NAME||"mexc-ultimate");
          const SCHEMA_VERSION=(process.env.SCHEMA_VERSION||"1");
          const GIT_SHA=(process.env.GIT_SHA||"unknown");
          
          const TOP_N=Number(process.env.TOP_N||"3"), MAX_SPREAD_BPS=Number(process.env.MAX_SPREAD_BPS||"12");
          const EXP_LCB_MIN_BPS_BASE=Number(process.env.EXP_LCB_MIN_BPS||"12");
          const EMA_FAST=21, EMA_SLOW=50, ADX_P=14, ATR_P=14, K5M=300, K1H=300;
          const COST_BPS=Number(process.env.FEES_BPS||"10"), NOTIONAL=Number(process.env.NOTIONAL_USD||"300");
          const DEPTH_LIMIT=Number(process.env.MEXC_DEPTH_LIMIT||"50"), OBI_TOPN=Number(process.env.OBI_TOPN||"12");
          const COOLDOWN_MS=3*60*60*1000, TTL_MIN=540, TTL_MAX=1200;
          const S_H=process.env.ACTIVE_UTC_START?Number(process.env.ACTIVE_UTC_START):null;
          const E_H=process.env.ACTIVE_UTC_END?Number(process.env.ACTIVE_UTC_END):null;
          const nowH=new Date().getUTCHours();
          const todOK=(S_H==null||E_H==null)?true:(S_H<=E_H?(nowH>=S_H&&nowH<=E_H):(nowH>=S_H||nowH<=E_H));
          const DIRECTION=(process.env.DIRECTION||"both").trim().toLowerCase();
          const MR_BREAKOUT_DC_N=Number(process.env.MR_BREAKOUT_DC_N||"120"), MR_LOCKOUT_SEC=Number(process.env.MR_LOCKOUT_SEC||"1800");
          const MIN_VOL_1H_USD=Number(process.env.MIN_VOL_1H_USD||"5000000"), DEPTH_1P_MIN_USD=Number(process.env.DEPTH_1P_MIN_USD||"200000");
          const NO_LONG_DOWN_ENABLE=(process.env.NO_LONG_DOWN_ENABLE||"true").toLowerCase()==="true";
          const LONG_DOWN_RSI_CUTOFF=Number(process.env.LONG_DOWN_RSI_CUTOFF||"40");
          const LONG_EDGE_MULT_MIN=Number(process.env.LONG_EDGE_MULT_MIN||"4");
          const LONG_BOUNCE_SL_ATR=Number(process.env.LONG_BOUNCE_SL_ATR||"0.50"), LONG_BOUNCE_TP_ATR=Number(process.env.LONG_BOUNCE_TP_ATR||"0.90");
          const CAPITAL_PCT_PER_TRADE=Number(process.env.CAPITAL_PCT_PER_TRADE||"0");
          const FIXED_SIZE_BPS = CAPITAL_PCT_PER_TRADE > 0 ? Math.min(2000, Math.round(CAPITAL_PCT_PER_TRADE * 100)) : 0;
          
          const CONFIG_HASH=(()=>{ try{ return hashObj({ DIRECTION, MR_BREAKOUT_DC_N, MR_LOCKOUT_SEC, MIN_VOL_1H_USD, DEPTH_1P_MIN_USD, NO_LONG_DOWN_ENABLE, LONG_DOWN_RSI_CUTOFF, LONG_EDGE_MULT_MIN, LONG_BOUNCE_SL_ATR, LONG_BOUNCE_TP_ATR, TOP_N, MAX_SPREAD_BPS, EXP_LCB_MIN_BPS_BASE, COST_BPS, NOTIONAL, DEPTH_LIMIT, OBI_TOPN, MIN_TF_ALIGN, TF_WEIGHTS }); }catch{ return "cfg-unknown"; } })();

          const PUSH_URL=process.env.WORKER_PUSH_URL||"", PUSH_TOKEN=process.env.PUSH_TOKEN||"";
          const PUSH_URL_V2 = process.env.WORKER_PUSH_URL_V2 || "";

          // ---------- MEXC Adapter ----------
          async function pickMexcBase(){ for(const b of MEXC_BASES){ try{ const r=await fetchWithTimeout(`${b}/api/v3/time`,{},4000); if(r?.ok) return b; }catch{} } throw new Error("No healthy MEXC base"); }
          const BASE=await pickMexcBase();
          const api=(path,params={})=>{ const u=new URL(path,BASE); for(const [k,v] of Object.entries(params)){ if(v!==undefined&&v!==null) u.searchParams.set(k,String(v)); } return u.toString(); };
          async function mexcSignedRequest(path, params = {}, method = 'GET') { if (!MEXC_API_KEY || !MEXC_SECRET_KEY) return null; const timestamp = Date.now(); const queryString = new URLSearchParams({ ...params, timestamp }).toString(); const signature = crypto.createHmac('sha256', MEXC_SECRET_KEY).update(queryString).digest('hex'); const url = new URL(path, BASE); url.search = queryString + `&signature=${signature}`; const options = { method, headers: { 'X-MEXC-APIKEY': MEXC_API_KEY, 'Content-Type': 'application/json', 'User-Agent': UA } }; try { const r = await fetchWithTimeout(url.toString(), options, 15000); if (r.ok) return await r.json(); return null; } catch (e) { return null; } }
          async function fetchOpenOrders(symbol) { return await mexcSignedRequest('/api/v3/openOrders', symbol?{symbol}:{}); }
          async function fetchK(sym,interval,limit){ const u=api("/api/v3/klines",{symbol:sym,interval,limit}); return await getJSON(u,10000,2); }
          async function fetchAll24hr(){ return await getJSON(api("/api/v3/ticker/24hr"),10000,2); }
          async function fetchBookTicker(symbol){ return await getJSON(api("/api/v3/ticker/bookTicker",{symbol}), 8000, 1); }
          async function getKCached(symbol,interval,limit){ const key=[symbol,interval,limit].join("|"); const c=getCached(cache.k,key,TTL.k); if(c) return c; const v=await fetchK(symbol,interval,limit); if(v) setCached(cache.k,key,v); return v; }
          async function getDepthCached(symbol){ const c=getCached(cache.depth,symbol,TTL.depth); if(c) return c; const v=await getJSON(api("/api/v3/depth",{symbol,limit:DEPTH_LIMIT}), 10000, 2); if(v) setCached(cache.depth,symbol,v); return v; }
          async function getBookTickerCached(symbol){ const c=getCached(cache.bt,symbol,TTL.bt); if(c) return c; const v=await fetchBookTicker(symbol); if(v) setCached(cache.bt,symbol,v); return v; }
          async function getKMultiTF(symbol){ const pairs=[["1m",300],["3m",300],["5m",K5M],["15m",300],["30m",300],["1h",K1H],["2h",200],["4h",300],["12h",120],["1d",90]]; const out={}; for(const [tf,lim] of pairs){ out[tf]=await getKCached(symbol, tf, lim); } return out; }

          // ---------- State (Gist) & Heartbeat ----------
          async function loadState(){
            const token=process.env.GIST_TOKEN, id=process.env.GIST_ID;
            const init={ v:"mexc-ultimate-7.2-final-fixes", cooldown:{}, cooldown_side:{}, pending:[], equity:[], closed:[], mr_lockout:{}, sym_stats:{}, sym_stats_real:{}, lastReconcileTs:0, ml_voting_history:[], model_weights:{ "Original":10, "Logistic":10, "NaiveBayes":10, "KNN":10, "Perceptron":10, "DecisionTree":10, "RandomForest":10, "NeuralNet":10, "MeanReversion":10, "Momentum":10 }, model_weights_prev:{} };
            if(!token||!id) return { state:init, persist:null };
            try{
              const r=await fetchWithTimeout(`https://api.github.com/gists/${id}`,{ headers:{Authorization:`Bearer ${token}`,"Accept":"application/vnd.github+json","User-Agent":UA} });
              if(!r.ok) return { state:init, persist:null };
              const g=await r.json(); const c=g.files?.["state.json"]?.content; const s=c?JSON.parse(c):init;
              if(!s.cooldown)s.cooldown={}; if(!s.cooldown_side)s.cooldown_side={}; if(!Array.isArray(s.pending))s.pending=[]; if(!Array.isArray(s.closed))s.closed=[]; if(!Array.isArray(s.equity))s.equity=[]; if(!s.mr_lockout)s.mr_lockout={}; if(!s.sym_stats)s.sym_stats={}; if(!s.sym_stats_real)s.sym_stats_real={}; if(!s.lastReconcileTs)s.lastReconcileTs=0; if(!Array.isArray(s.ml_voting_history))s.ml_voting_history=[];
              if(!s.model_weights || Object.keys(s.model_weights).length < 10) s.model_weights={ "Original":10, "Logistic":10, "NaiveBayes":10, "KNN":10, "Perceptron":10, "DecisionTree":10, "RandomForest":10, "NeuralNet":10, "MeanReversion":10, "Momentum":10 };
              if(!s.model_weights_prev)s.model_weights_prev={};
              return { state:s, persist:{ id, token, etag:r.headers.get("etag") } };
            }catch(e){ log("loadState warn", e?.message||e); return { state:init, persist:null }; }
          }
          
          async function saveState(persist, state) { if (!persist) return; const gistUrl = `https://api.github.com/gists/${persist.id}`; const mkFiles = (s) => ({ "state.json": { content: JSON.stringify(s) } }); async function patch(files, etag) { const headers = { Authorization: `Bearer ${persist.token}`, "Accept": "application/vnd.github+json", "Content-Type": "application/json", "User-Agent": UA }; if (etag) headers["If-Match"] = etag; return await fetchWithTimeout(gistUrl, { method: "PATCH", headers, body: JSON.stringify({ files }) }, 15000); } let r = await patch(mkFiles(state), persist.etag); if (r.ok) { persist.etag = r.headers.get("etag") || persist.etag; return log("SUCCESS: Gist updated!"); } log("WARN: Gist save failed status=", r.status, ". Retrying with blind PATCH."); const r2 = await patch(mkFiles(state), null); if(!r2.ok) log("ERROR: Blind save failed status=", r2.status); }
          
          // ========== FEATURE EXTRACTION & VOTING SYSTEM ==========
          const extractMLFeatures=(c5,h5,l5,v5,rsi14,adx5,atr_bps,z_vwap,roc1,roc3,spreadBps,obi,ofi30s,mtfAgg)=>{ return [ (roc1||0), (roc3||0), ((atr_bps||0)/100), ((rsi14||50)/100), ((adx5||0)/100), (z_vwap||0), ((spreadBps||0)/100), (obi||0), (ofi30s||0), ((mtfAgg.rsi||50)/100), ((mtfAgg.adx||0)/100), 0,0,0,0, (mean(v5.slice(-20))||0)/1e6, (std(v5.slice(-20))||0)/1e6, (std(c5.slice(-20))||0)/100 ]; };
          const predictLogistic = (feat) => { const score = (feat[0] * 2) + (feat[1] * 1.5) - (feat[6] * 3); return score > 0 ? "long" : "short"; };
          const predictNaiveBayes = (feat) => { let bullishSignals = 0; if (feat[3] < 0.35) bullishSignals++; if (feat[5] < -1.2) bullishSignals++; if (feat[7] < -0.25) bullishSignals++; return bullishSignals >= 2 ? "long" : "short"; };
          const predictKNN = (feat) => { const idealLong = [0.01, 0.02, 0.5, 0.3, 0.4, -1.2, 0.05, -0.3]; const idealShort = [-0.01, -0.02, 0.5, 0.7, 0.4, 1.2, 0.05, 0.3]; const distLong = feat.slice(0,8).reduce((s,f,i)=>s + (f-idealLong[i])**2, 0); const distShort = feat.slice(0,8).reduce((s,f,i)=>s + (f-idealShort[i])**2, 0); return distLong < distShort ? "long" : "short"; };
          const predictPerceptron = (feat) => { const score = (feat[3] - 0.5) * -2 + (feat[5] * -1.5) + (feat[7] * -2); return score > 0 ? "long" : "short"; };
          const predictDecisionTree = (feat) => { if (feat[4] > 0.3) return feat[0] > 0 ? "long" : "short"; else return feat[5] < 0 ? "long" : "short"; };
          const predictRandomForest = (feat) => { let votes = 0; if (feat[3] < 0.4) votes++; else votes--; if (feat[5] < -0.5) votes++; else votes--; if (feat[7] < -0.1) votes++; else votes--; return votes > 0 ? "long" : "short"; };
          const predictNeuralNet = (feat) => { const hidden1 = Math.tanh(feat[0]*3 + feat[5]*2); const hidden2 = Math.tanh(feat[3]*-2 + feat[7]*-1.5); const output = hidden1 * 0.6 + hidden2 * 0.4; return output > 0 ? "long" : "short"; };
          const predictMeanReversion = (feat) => { const z_vwap = feat[5] || 0; const rsi = feat[3] * 100 || 50; const obi = feat[7] || 0; let score = 0; if ((rsi < 30 && z_vwap < -1.5) || obi < -0.3) score++; if ((rsi > 70 && z_vwap > 1.5) || obi > 0.3) score--; return score >= 0 ? "long" : "short"; };
          const predictMomentum = (feat) => { const adx = feat[4] * 100 || 0; let score = 0; if (adx > 25 && (feat[0] > 0 && feat[1] > 0)) score = 1; if (adx > 25 && (feat[0] < 0 && feat[1] < 0)) score = -1; return score >= 0 ? "long" : "short"; };
          
          async function mlEnsembleVote(symbol, features, originalSide, state) { const weights = state.model_weights || {}; const getWeight = (model) => { const w = weights[model]; return (typeof w === 'number' && w >= 0 && w <= 20) ? w : 10; }; let longScore = 0, shortScore = 0; const details = [], votes = {}; const w0 = getWeight("Original"); if (originalSide === "long") longScore += w0; else shortScore += w0; details.push({ model: "Original", vote: originalSide, weight: w0 }); votes["Original"] = originalSide; const v1 = predictLogistic(features); const w1 = getWeight("Logistic"); if(v1 === "long") longScore += w1; else shortScore += w1; details.push({model:"Logistic", vote:v1, weight:w1}); votes["Logistic"]=v1; const v2 = predictNaiveBayes(features); const w2 = getWeight("NaiveBayes"); if(v2 === "long") longScore += w2; else shortScore += w2; details.push({model:"NaiveBayes", vote:v2, weight:w2}); votes["NaiveBayes"]=v2; const v3 = predictKNN(features); const w3 = getWeight("KNN"); if(v3 === "long") longScore += w3; else shortScore += w3; details.push({model:"KNN", vote:v3, weight:w3}); votes["KNN"]=v3; const v4 = predictPerceptron(features); const w4 = getWeight("Perceptron"); if(v4 === "long") longScore += w4; else shortScore += w4; details.push({model:"Perceptron", vote:v4, weight:w4}); votes["Perceptron"]=v4; const v5 = predictDecisionTree(features); const w5 = getWeight("DecisionTree"); if(v5 === "long") longScore += w5; else shortScore += w5; details.push({model:"DecisionTree", vote:v5, weight:w5}); votes["DecisionTree"]=v5; const v6 = predictRandomForest(features); const w6 = getWeight("RandomForest"); if(v6 === "long") longScore += w6; else shortScore += w6; details.push({model:"RandomForest", vote:v6, weight:w6}); votes["RandomForest"]=v6; const v7 = predictNeuralNet(features); const w7 = getWeight("NeuralNet"); if(v7 === "long") longScore += w7; else shortScore += w7; details.push({model:"NeuralNet", vote:v7, weight:w7}); votes["NeuralNet"]=v7; const v8 = predictMeanReversion(features); const w8 = getWeight("MeanReversion"); if(v8 === "long") longScore += w8; else shortScore += w8; details.push({model:"MeanReversion", vote:v8, weight:w8}); votes["MeanReversion"]=v8; const v9 = predictMomentum(features); const w9 = getWeight("Momentum"); if(v9 === "long") longScore += w9; else shortScore += w9; details.push({model:"Momentum", vote:v9, weight:w9}); votes["Momentum"]=v9; const majoritySide = longScore >= shortScore ? 'long' : 'short'; const confidenceBoost = Math.round(Math.abs(longScore - shortScore) / 10); const totalWeight = longScore + shortScore; const agreement = (Math.max(longScore, shortScore) / (totalWeight || 1)).toFixed(2); return { ensemble_side: majoritySide, votes_long: longScore, votes_short: shortScore, confidence_boost: confidenceBoost, agreement: agreement, details: details, votes: votes }; }
          
          // ---------- Main ----------
          try{
            const { state, persist } = await loadState();
            function updateModelWeights(state) {
              const learnable = (state.closed || []).filter(c => c.ml_ensemble?.votes && c.pnl_bps != null && !c.weights_learned);
              if (!learnable.length) return;
              log(`ðŸŽ¯ LEARNING WEIGHTS FROM ${learnable.length} CLOSED TRADES`);
              for (const trade of learnable) {
                const isWin = (trade.pnl_bps || 0) > 0, takenSide = trade.side, votes = trade.ml_ensemble?.votes || {};
                for (const [model, votedSide] of Object.entries(votes)) {
                    if (!state.model_weights[model]) continue;
                    const oldWeight = state.model_weights[model];
                    const wasCorrect = ((votedSide === takenSide) && isWin) || ((votedSide !== takenSide) && !isWin);
                    state.model_weights[model] = clamp(oldWeight + (wasCorrect ? 1 : -1), 0, 20);
                }
                trade.weights_learned = true;
              }
            }
            updateModelWeights(state);

            const ALL24 = await fetchAll24hr() || [];
            const booksRaw=await getJSON(api("/api/v3/ticker/bookTicker")) || [];
            const bookMap=new Map(booksRaw.map(b=>[b.symbol,{ bid:+b.bidPrice, ask:+b.askPrice }]));
            
            const FIXED_120_BASES = ["BTC","ETH","BNB","SOL","XRP","ADA","AVAX","DOGE","DOT","MATIC","LTC","SHIB","TRX","LINK","ATOM","UNI","XLM","ETC","BCH","NEAR","APT","ARB","OP","LDO","STX","IMX","INJ","VET","FIL","HBAR","MKR","AAVE","QNT","GRT","ALGO","RUNE","SAND","MANA","XTZ","AXS","EOS","THETA","FTM","ICP","EGLD","FLOW","XMR","APE","CHZ","KLAY","GALA","SNX","CRV","ZEC","ENJ","DASH","NEO","COMP","KCS","ZIL","BAT","WAVES","IOTA","1INCH","LRC","SUSHI","YFI","RVN","CELO","HOT","OMG","ZRX","ICX","ONT","QTUM","SKL","AR","GMT","JST","RSR","ONE","AUDIO","ANKR","CKB","MASK","DYDX","BLUR","SUI","SEI","TIA","JUP","WLD","PEPE","FET","RENDER","AGIX","ORDI","WIF","BONK","FLOKI","PYTH","JTO","STRK","MEME","DYM","PORTAL","XAI","ALT","PIXEL","AEVO","NFP","ACE","RDNT","MAV","PENDLE","AI","ID","JOE"];
            const QUOTES=["USDT","USDC","USD"];
            const all24Map=new Map(ALL24.map(t=>[t.symbol,t]));
            const universe=[];
            for(const base of FIXED_120_BASES){
              for(const q of QUOTES){ const t=all24Map.get(base+q); if(t?.quoteVolume>0){ universe.push({ symbol:base+q, base, quote:q, qv:+t.quoteVolume }); break; } }
            }
            
            const picksRaw=[];
            for(let i=0;i<universe.length;i+=10){
              const batch=await Promise.all(universe.slice(i,i+10).map(async c=>{ try{
                if((state.cooldown?.[c.base]||0) > Date.now()-COOLDOWN_MS) return null;
                const book=bookMap.get(c.symbol) || await getBookTickerCached(c.symbol); if(!book?.bid || !book?.ask) return null;
                const mid=(+book.bid + +book.ask)/2; if(!mid) return null;
                const k5=await getKCached(c.symbol,"5m",K5M); if(!k5||k5.length<EMA_SLOW+5) return null;
                const c5_raw=k5.map(x=>+x[4]), c5=kalman1D(c5_raw,{q:1e-4,r:5e-4});
                const h5=k5.map(x=>+x[2]), l5=k5.map(x=>+x[3]), v5=k5.map(x=>+x[5]);
                const {adx:adx5, atr:atr5} = computeADX_ATR(h5,l5,c5,ADX_P)||{}; if(!atr5) return null;
                const atr_bps=Math.round((atr5/(c5.at(-1)||1))*10000); if(atr_bps<4||atr_bps>260) return null;
                const last=c5.at(-1), roc1=(last/(c5.at(-2)||last))-1, roc3=(last/(c5.at(-4)||last))-1;
                const z_vwap=(last-vwapAnchored(h5,l5,c5,v5,36))/(atr5||1);
                const pTrend=clamp(0.5+0.27*(0.6*tanh(roc1/0.003)+0.4*tanh(roc3/0.0065))*clamp((adx5-16)/14,0,1),0.32,0.93);
                const pMR=clamp(0.5+0.23*(0.7*tanh(Math.abs(z_vwap))*Math.sign(-z_vwap)+0.3*(-(rsi(c5,14)-50)/50))*(1-clamp((adx5-16)/14,0,1)),0.35,0.90);
                return {c,p_raw:clamp(0.45*pTrend+0.55*pMR,0.3,0.97), c5_raw,h5_raw:h5,l5_raw:l5,v5_raw:v5,z_vwap,rsi14:rsi(c5,14),adx5,atr_bps,obi:0,ofi30s:0};
              }catch{ return null; } }));
              for(const x of batch) if(x) picksRaw.push(x);
            }

            const prelim=picksRaw.sort((a,b)=>Math.abs(b.p_raw-0.5)-Math.abs(a.p_raw-0.5)).slice(0,30);

            const refined = [];
            for (let p of prelim) {
              const book=bookMap.get(p.c.symbol);
              const mid = book ? (+book.bid + +book.ask)/2 : null;
              if (!mid) continue;
              
              const side = p.p_raw > 0.5 ? "long" : "short";
              const tp = side === "long" ? Math.round(LONG_BOUNCE_TP_ATR * p.atr_bps) : Math.round(p.atr_bps * 1.0);
              const sl = side === "long" ? Math.min(Math.round(LONG_BOUNCE_SL_ATR * p.atr_bps), 80) : Math.min(Math.round(p.atr_bps * 0.5), 80);
              if (tp/sl < 1.4) continue;

              const mtf = computeMTFIndicators(await getKMultiTF(p.c.symbol), TF_WEIGHTS);
              const confidence = Math.round(100 * p.p_raw * (0.6 + 0.5 * mtf.tfAlign) );
              refined.push({ symbol: p.c.symbol, base: p.c.base, quote: p.c.quote, side, p_raw: p.p_raw, confidence, tp_bps: tp, sl_bps: sl, mtf_agg: mtf.agg, ...p });
            }
            refined.sort((a,b)=>b.confidence-a.confidence);

            let selected=refined.slice(0, TOP_N);
            
            for(let pick of selected.slice(0, 10)){
              const features=extractMLFeatures(pick.c5_raw, pick.h5_raw, pick.l5_raw, pick.v5_raw, pick.rsi14, pick.adx5, pick.atr_bps, pick.z_vwap, 0,0,0, pick.obi, pick.ofi30s, pick.mtf_agg);
              const oldSide=pick.side;
              const ensemble=await mlEnsembleVote(pick.symbol,features,oldSide,state);
              pick.side=ensemble.ensemble_side; pick.confidence+=ensemble.confidence_boost;
              pick.ml_ensemble=ensemble; pick.ml_features=features;
            }
            selected.sort((a,b)=>b.confidence-a.confidence);

            let picks = selected.map(p => {
              const book = bookMap.get(p.symbol);
              if (!book || !isFinite(+book.bid) || !isFinite(+book.ask)) return null;
              const mid = (+book.bid + +book.ask) / 2;
              const size = FIXED_SIZE_BPS > 0 ? FIXED_SIZE_BPS : (Number(process.env.FORCE_SIZE_BPS||"0")>0) ? Number(process.env.FORCE_SIZE_BPS) : (p.sl_bps>0?Math.min(220,Math.round((52/p.sl_bps)*100)):0);
              const entry_limit = p.side === 'long' ? mid * (1 - p.sl_bps/20000) : mid * (1 + p.sl_bps/20000);
              return { ...p, idea_id:uuidv4(), client_order_id:mkClientOrderId("mxu"), symbol_full:p.symbol, p_win:p.p_raw, ev_bps: p.p_raw * p.tp_bps - (1-p.p_raw)*p.sl_bps, size_bps: size, ttl_sec: TTL_MIN, cost_bps: COST_BPS, entry_policy:"maker_join", entry_limit, tp_abs: entry_limit * (1 + (p.side==='long'?1:-1)*p.tp_bps/10000), sl_abs: entry_limit * (1 - (p.side==='long'?1:-1)*p.sl_bps/10000), predicted:{meta:{}} };
            }).filter(Boolean);

            const nowMs = Date.now();
            for (const p of picks) {
              state.cooldown[p.base] = nowMs;
              state.cooldown_side[p.base] = { side: p.side, ts_ms: nowMs };
              state.pending.push({
                ts: new Date(nowMs).toISOString(), ts_ms: nowMs, ttl_ts_ms: nowMs + p.ttl_sec * 1000,
                symbolFull: p.symbol_full, base: p.base, side: p.side, idea_id: p.idea_id, client_order_id: p.client_order_id,
                hold_sec: p.ttl_sec, tp_bps: p.tp_bps, sl_bps: p.sl_bps, size_bps: p.size_bps, p_raw: p.p_raw,
                predicted: p.predicted, status: "planned", entry_ts_ms: null, entry_price: null, qty: null
              });
            }
            if (state.pending.length > 550) state.pending = state.pending.slice(-550);
            
            await saveState(persist, state);

            const payload = { ts:new Date().toISOString(), source:"external_pusher", meta:{}, top_n:picks.length, ideas:picks };
            log(`pushing ${picks.length} ideas to ${PUSH_URL}`);
            const r = await fetchWithTimeout(PUSH_URL,{ method:"POST", headers:{ "Content-Type":"application/json", "Authorization":"Bearer " + PUSH_TOKEN }, body: JSON.stringify(payload) },15000);
            log("push status", r?.status||"ERR", (await r.text()||"").slice(0,400));
          }catch(e){
            log("FATAL ERROR", e?.message||e, e?.stack||"");
          }
          })();
          NODE

          EXIT_CODE=$?

          set -e
          if [[ $EXIT_CODE -ne 0 ]]; then
            echo "[gha] pusher exited with code $EXIT_CODE â€” sending minimal payload"
            raw_push_url="$(printf '%s' "${WORKER_PUSH_URL}" | tr -d '\r\n')"
            payload='{"ts":"'$(date -u +"%Y-%m-%dT%H:%M:%SZ")'","source":"external_pusher","meta":{"reason":"fallback_node_error"},"top_n":0,"ideas":[]}'
            curl -g -sS -o /dev/null -w "%{http_code}" -X POST -H "Content-Type: application/json" -H "Authorization: Bearer ${PUSH_TOKEN}" --data-raw "${payload}" --max-time 12 "${raw_push_url}" || true
            exit 0
          fi
